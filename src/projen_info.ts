import * as fs from "fs";
import * as vscode from "vscode";
import { GeneratedFileDecorationProvider } from "./generated_file_decorator";

export class ProjenInfo {
  public managedFiles: string[] = [];
  public tasks: ProjenTask[] = [];
  public dependencies: ProjenDependency[] = [];
  decorator: GeneratedFileDecorationProvider;

  constructor(public workspaceRoot: string) {
    this.decorator = new GeneratedFileDecorationProvider();
    vscode.window.registerFileDecorationProvider(this.decorator);
  }

  async update() {
    const files = await vscode.workspace.findFiles(
      new vscode.RelativePattern(this.workspaceRoot, "*")
    );
    const projenFolderFiles = await vscode.workspace.findFiles(
      new vscode.RelativePattern(this.workspaceRoot, ".projen/*")
    );
    files.push(...projenFolderFiles);

    if (projenFolderFiles.length == 0) {
      void vscode.commands.executeCommand(
        "setContext",
        "projen.inProject",
        false
      );

      this.managedFiles = [];
      this.dependencies = [];
      this.decorator.files = [];

      return;
    }

    void vscode.commands.executeCommand("setContext", "projen.inProject", true);

    const projenManaged: vscode.Uri[] = [];
    files.forEach((f) => {
      if (
        f.fsPath.endsWith("package-lock.json") ||
        f.fsPath.endsWith(".lock")
      ) {
        // TODO handle lockfiles in a smarter way
        // Since dependencies are managed by projen, a lockfile is as well (kinda)
        // lock files are typically huge, would much rather not try to search them
        projenManaged.push(f);
      } else {
        const fileContent = fs.readFileSync(f.fsPath, "utf-8");
        if (
          fileContent.includes(
            `~~` + ` Generated by projen. To modify, edit .projenrc`
          )
        ) {
          projenManaged.push(f);
          if (f.fsPath.endsWith("tasks.json")) {
            const taskData = JSON.parse(fileContent).tasks;

            this.tasks = Object.values(taskData).map(
              (t: any) => new ProjenTask(t)
            );
            this.tasks.sort((a, b) => a.name.localeCompare(b.name));
          } else if (f.fsPath.endsWith("deps.json")) {
            const depData = JSON.parse(fileContent).dependencies;
            depData.sort((a: any, b: any) => a.name.localeCompare(b.name));

            this.dependencies = depData.map(
              (d: any) => new ProjenDependency(d.name, d.type, d.version)
            );
          }
        }
      }
    });

    this.decorator.files = projenManaged.map((f) => f.fsPath);

    this.managedFiles = projenManaged.map((file: vscode.Uri) => {
      const removedRoot = file.fsPath.replace(this.workspaceRoot, "");
      const betterFile = removedRoot.replace(/\\/g, "/");

      if (betterFile.startsWith("/")) {
        return betterFile.slice(1);
      } else {
        return betterFile;
      }
    });
    this.managedFiles.sort();

    this.decorator._onDidChangeFileDecorations.fire(projenManaged);
  }
}
export class ProjenStep {
  constructor(public type: string, public value: string) {}
}

export class ProjenTask {
  public name: string;
  public description?: string;
  public steps: ProjenStep[];

  constructor(taskData: any) {
    this.name = taskData.name;
    this.description = taskData.description;
    this.steps = (taskData.steps ?? []).map((s: any) => {
      const entries = Object.entries(s)[0];
      return new ProjenStep(entries[0], entries[1] as any);
    });
  }
}

export class ProjenDependency {
  constructor(
    public name: string,
    public type: string,
    public version?: string
  ) {}
}
